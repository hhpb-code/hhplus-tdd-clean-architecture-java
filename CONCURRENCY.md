# 분산 환경에서의 동시성 제어

## 배경

- 동시성 제어의 기본 개념 이해를 위해 [멀티 스레드 환경에서 동시성 제어 방식에 대한 분석 In Java](https://penguin-dev.tistory.com/8) 글
  참고

## 분산 환경 vs 멀티 스레드 환경

- 멀티 스레드 환경: 단일 인스턴스, 인스턴스 레벨 동시성 제어 가능
- 분산 환경: 다중 인스턴스, 인스턴스 레벨 제어 불가능

## 분산 환경에서의 동시성 제어 방식

1. 락(Lock)을 이용한 제어
    - 원리: 공유 자원에 대한 접근을 순차적으로 제어
    - 장점: 구현이 상대적으로 간단, 데이터 일관성 보장
    - 단점: 성능 저하 가능성, 데드락 위험

2. 버전(Version)을 이용한 제어
    - 원리: 데이터 변경 시 버전 정보 업데이트
    - 장점: 충돌 감지 용이, 낙관적 동시성 제어에 적합
    - 단점: 추가적인 버전 관리 오버헤드

3. 타임스탬프(Timestamp)를 이용한 제어
    - 원리: 각 트랜잭션에 고유한 타임스탬프 부여
    - 장점: 시간 기반 일관성 제공, 이력 추적 용이
    - 단점: 시계 동기화 문제, 높은 오버헤드 가능성

4. 캐시(Cache)를 이용한 제어
    - 원리: 자주 사용되는 데이터를 로컬에 저장 및 관리
    - 장점: 빠른 데이터 접근, 네트워크 부하 감소
    - 단점: 캐시 일관성 유지의 어려움, 추가적인 동기화 메커니즘 필요

5. 분산락(Distributed Lock)을 이용한 제어
    - 원리: 분산 환경에서 공유 자원에 대한 접근을 조정하기 위해 중앙화된 락 관리 시스템 사용
    - 장점:
        - 분산 환경에서 강력한 일관성 보장
        - 여러 노드 간 동기화 용이
        - 세밀한 락 관리 가능 (예: 읽기/쓰기 락 구분)
    - 단점:
        - 락 서버의 단일 장애점 가능성
        - 네트워크 지연으로 인한 성능 저하 가능성
        - 구현 및 운영의 복잡성
    - 구현 예시: Redis, ZooKeeper, etcd 등을 이용한 분산락 구현

## 비교 분석

- 성능 측면:
    - 캐시 > 버전 > 타임스탬프 > 분산락 > 락
- 구현 복잡도:
    - 락 < 버전 < 타임스탬프 < 캐시 < 분산락
- 일관성 보장:
    - 분산락 ≈ 락 > 버전 > 타임스탬프 > 캐시
- 분산 환경 적합성:
    - 분산락 > 버전 > 캐시 > 타임스탬프 > 락

## 선택 기준

- 시스템 요구사항 (성능, 일관성, 가용성)
- 데이터 특성 (갱신 빈도, 크기)
- 인프라 환경 (네트워크 지연, 노드 수)
- 개발 및 유지보수 복잡도

## 결론

각 방식은 상황에 따라 장단점이 다르므로, 시스템의 특성과 요구사항을 고려해 적절한 방식이나 복합적인 접근을 선택해야 한다.  
모든건 상황에 따라 다르며 트레이드 오프(Trade-off)를 고려해야 한다.  
이번 프로젝트는 분산 환경에서의 동시성 제어를 고려해야 하므로, 분산락을 이용한 제어 방식을 적용하는 것이 적합할 것으로 판단된다.  
하지만 아직 배우지 않은 Redis, ZooKeeper, etcd 등을 이용한 분산락 구현은 복잡도가 높기 때문에, 락을 이용한 제어 방식을 우선 적용하고, 추후 분산락을 적용하는
것도 고려해볼 수 있다.  
버전이나 타임스탬프를 이용한 방법은 데이터 변경이 빈번하게 일어나는 경우에는 적합하지 않다고 생각해서 사용하지 않았다.
캐시는 데이터 일관성 유지가 어렵고 추가적인 동기화 메커니즘이 필요하다고 생각해서 사용하지 않았다.
그래서 단순한 락을 이용한 방법을 사용하였다.
